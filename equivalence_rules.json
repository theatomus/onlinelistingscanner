{
    "storage_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower().strip(),\n                v2_lower := v2.lower().strip(),\n                v1_lower in v2_lower or v2_lower in v1_lower or\n                (\n                    v1_parts := set(re.split(r'[ -]+', v1_lower)) - {''},\n                    v2_parts := set(re.split(r'[ -]+', v2_lower)) - {''},\n                    (v1_parts.issubset(v2_parts) or v2_parts.issubset(v1_parts)) if v1_parts and v2_parts else True\n                )\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                storage_types := [\"emmc\", \"ssd\", \"hdd\", \"nvme\", \"sata\"],\n                v1_lower := v1.lower(),\n                v2_lower := v2.lower(),\n                any(\n                    (v1_lower == st and re.search(rf'\\d+(gb|tb)\\s*{st}', v2_lower)) or\n                    (v2_lower == st and re.search(rf'\\d+(gb|tb)\\s*{st}', v1_lower))\n                    for st in storage_types\n                )\n            ) and (\n                logger.debug(f\"Matched '{v1_lower}' with '{v2_lower}' as storage type vs type+capacity\", extra={'session_id': current_session_id}) or True\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                (\"no\" in v1.lower() and \"no\" in v2.lower() and \"storage\" in v1.lower() + v2.lower()) or\n                (v1.lower() in [\"no storage\", \"none\", \"no\", \"n/a\", \"no (m.2)\"] and\n                 v2.lower() in [\"no storage\", \"none\", \"no\", \"n/a\", \"no (m.2)\", \"no (sata hdd/ssd)\"]) or\n                (v2.lower() in [\"no storage\", \"none\", \"no\", \"n/a\", \"no (m.2)\"] and\n                 v1.lower() in [\"no storage\", \"none\", \"no\", \"n/a\", \"no (m.2)\", \"no (sata hdd/ssd)\"]) or\n                (\"nvme\" in v1.lower() and re.search(r'\\d+(gb|tb)\\s*nvme', v2.lower())) or\n                (\"nvme\" in v2.lower() and re.search(r'\\d+(gb|tb)\\s*nvme', v1.lower())) or\n                (title and 'title_storage_key' in title and v1 == title['title_storage_key'] and\n                 re.search(rf\"{get_capacity(title, 'title_')}\\s*{v1.lower()}\", v2.lower())) or\n                (title and 'title_storage_key' in title and v2 == title['title_storage_key'] and\n                 re.search(rf\"{get_capacity(title, 'title_')}\\s*{v2.lower()}\", v1.lower()))\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower(),\n                v2_lower := v2.lower(),\n                ((\"ssd\" in v1_lower and \"nvme\" in v2_lower) or (\"nvme\" in v1_lower and \"ssd\" in v2_lower)) and\n                (\n                    specs_capacity := get_capacity(specs, 'specs_') if specs else \"\",\n                    table_capacity := get_capacity(table, 'table_') if table else \"\",\n                    (not specs_capacity and not table_capacity) or\n                    (specs_capacity and table_capacity and specs_capacity == table_capacity) or\n                    (specs_capacity and re.search(rf'{specs_capacity}\\s*(nvme|ssd)', v2_lower)) or\n                    (table_capacity and re.search(rf'{table_capacity}\\s*(nvme|ssd)', v1_lower))\n                )\n            ) and (\n                logger.debug(f\"Matched '{v1_lower}' with '{v2_lower}' as SSD/NVMe with capacity alignment\", extra={'session_id': current_session_id}) or True\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: partial_storage_match(v1, v2, include_capacity=True, is_mobile_device=is_mobile_device)"
    ],
    "storage_type_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower().strip(),\n                v2_lower := v2.lower().strip(),\n                v1_lower in v2_lower or v2_lower in v1_lower or\n                (\n                    v1_parts := set(re.split(r'[ -]+', v1_lower)) - {''},\n                    v2_parts := set(re.split(r'[ -]+', v2_lower)) - {''},\n                    (v1_parts.issubset(v2_parts) or v2_parts.issubset(v1_parts)) if v1_parts and v2_parts else True\n                )\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: partial_storage_match(v1, v2, include_capacity=False, is_mobile_device=is_mobile_device)"
    ],
    "storage_description_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower().strip(),\n                v2_lower := v2.lower().strip(),\n                v1_lower in v2_lower or v2_lower in v1_lower or\n                (\n                    v1_parts := set(re.split(r'[ -]+', v1_lower)) - {''},\n                    v2_parts := set(re.split(r'[ -]+', v2_lower)) - {''},\n                    (v1_parts.issubset(v2_parts) or v2_parts.issubset(v1_parts)) if v1_parts and v2_parts else True\n                )\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: has_no_storage(title, specs, table) or\n                (\"nvme\" in v1.lower() and re.search(r'\\d+(gb|tb)\\s*nvme', v2.lower())) or\n                (\"nvme\" in v2.lower() and re.search(r'\\d+(gb|tb)\\s*nvme', v1.lower()))",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: partial_storage_match(v1, v2, include_capacity=True, is_mobile_device=is_mobile_device)"
    ],
    "storage_capacity_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: v1.replace(\" \", \"\").lower() == v2.replace(\" \", \"\").lower()",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: partial_storage_match(v1, v2, include_capacity=True, is_mobile_device=is_mobile_device)"
    ],
    "ram_type_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower(),\n                v2_lower := v2.lower(),\n                (\"ecc\" in v1_lower and \"non-ecc\" in v2_lower) or\n                (\"non-ecc\" in v1_lower and \"ecc\" in v2_lower) or\n                ((\"ecc\" in v1_lower and \"ecc\" in v2_lower) or (\"non-ecc\" in v1_lower and \"non-ecc\" in v2_lower)) and v1_lower == v2_lower or\n                (\"ecc\" in v1_lower and \"ecc\" not in v2_lower and \"non-ecc\" not in v2_lower) or\n                (\"ecc\" in v2_lower and \"ecc\" not in v1_lower and \"non-ecc\" not in v1_lower) or\n                v1_lower in v2_lower or\n                v2_lower in v1_lower or\n                partial_match(v1, v2, title, specs, table)\n            )"
    ],
    "ram_capacity_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                val1_norm := re.sub(r'\\s+', '', v1.lower()),\n                val2_norm := re.sub(r'\\s+', '', v2.lower()),\n                (\n                    '-' in val1_norm and\n                    (\n                        parts := val1_norm.split('-'),\n                        len(parts) == 2 and\n                        (\n                            min_val := re.search(r'\\d+', parts[0]),\n                            max_val := re.search(r'\\d+', parts[1]),\n                            val2_num := re.search(r'\\d+', val2_norm),\n                            min_val and max_val and val2_num and\n                            int(min_val.group()) <= int(val2_num.group()) <= int(max_val.group())\n                        )\n                    )\n                ) or\n                (\n                    '-' in val2_norm and\n                    (\n                        parts := val2_norm.split('-'),\n                        len(parts) == 2 and\n                        (\n                            min_val := re.search(r'\\d+', parts[0]),\n                            max_val := re.search(r'\\d+', parts[1]),\n                            val1_num := re.search(r'\\d+', val1_norm),\n                            min_val and max_val and val1_num and\n                            int(min_val.group()) <= int(val1_num.group()) <= int(max_val.group())\n                        )\n                    )\n                ) or\n                (\n                    '/' in val1_norm and\n                    val2_norm in [re.sub(r'\\s+', '', opt.strip().lower()) for opt in v1.split('/')]\n                ) or\n                (\n                    '/' in val2_norm and\n                    val1_norm in [re.sub(r'\\s+', '', opt.strip().lower()) for opt in v2.split('/')]\n                ) or\n                val1_norm == val2_norm\n            )"
    ],
    "ram_modules_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: compare_ram_modules(v1, v2)"
    ],
    "ram_speed_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                float(re.search(r'(\\d+(?:\\.\\d+)?)', v1).group(1)) ==\n                float(re.search(r'(\\d+(?:\\.\\d+)?)', v2).group(1))\n                if re.search(r'(\\d+(?:\\.\\d+)?)', v1) and re.search(r'(\\d+(?:\\.\\d+)?)', v2)\n                else v1 == v2\n            )"
    ],
	"ram_size_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: v1.replace(',', '').replace(' ', '').lower() == v2.replace(',', '').replace(' ', '').lower()"
    ],
    "processor_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                family_match1 := re.search(r'i([3579])|m([3579])|ryzen\\s*(\\d)|m(\\d)', v1.lower()),\n                family_match2 := re.search(r'i([3579])|m([3579])|ryzen\\s*(\\d)|m(\\d)', v2.lower()),\n                gen_match1 := re.search(r'(\\d+)(?:th|st|nd|rd)?\\s*gen', v1.lower()),\n                gen_match2 := re.search(r'(\\d+)(?:th|st|nd|rd)?\\s*gen', v2.lower()),\n                model_match1 := re.search(r'[-](\\d{1,2})(\\d{3}[a-z]*)', v1.lower()),\n                model_match2 := re.search(r'[-](\\d{1,2})(\\d{3}[a-z]*)', v2.lower()),\n                brand_match := (\n                    (\"intel\" in v1.lower() and \"intel\" in v2.lower()) or\n                    (\"amd\" in v1.lower() and \"amd\" in v2.lower()) or\n                    (\"apple\" in v1.lower() and \"apple\" in v2.lower())\n                ),\n                family_same := family_match1 and family_match2 and any(\n                    family_match1.group(i) and family_match2.group(i)\n                    for i in range(1, 5) if family_match1.group(i) is not None\n                ),\n                gen_same := (\n                    (gen_match1 and gen_match2 and gen_match1.group(1) == gen_match2.group(1)) or\n                    (gen_match1 and model_match2 and gen_match1.group(1) == model_match2.group(1)) or\n                    (gen_match2 and model_match1 and gen_match2.group(1) == model_match1.group(1))\n                ),\n                brand_match and (family_same or gen_same)\n            ) and (\n                logger.debug(f\"Processor match found between '{v1}' and '{v2}'\", extra={'session_id': current_session_id}) or True\n            )"
    ],
    "cpu_family_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                (v1.lower().strip() in v2.lower().strip() or v2.lower().strip() in v1.lower().strip()) \n                if (\"xeon\" in v1.lower() and \"xeon\" in v2.lower()) \n                else bool(set(item.strip() for item in v1.split(',')) & set(item.strip() for item in v2.split(',')))\n            )"
    ],
    "cpu_suffix_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: bool(set(item.strip() for item in v1.split(',')) & set(item.strip() for item in v2.split(',')))"
    ],
    "cpu_model_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                nums1 := {int(part.strip()) for part in v1.split('/') if part.strip().isdigit()},\n                nums2 := {int(part.strip()) for part in v2.split('/') if part.strip().isdigit()},\n                bool(nums1 & nums2) if nums1 and nums2 else v1.lower().strip() == v2.lower().strip()\n            )"
    ],
    "model_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_norm := normalize_model(v1),\n                v2_norm := normalize_model(v2),\n                v1_clean := v1_norm.replace('-', '').lower(),\n                v2_clean := v2_norm.replace('-', '').lower(),\n                v1_clean in v2_clean or v2_clean in v1_clean\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_models := re.findall(r'([a-zA-Z0-9]+(?:[a-zA-Z][0-9]|[0-9][a-zA-Z])[a-zA-Z0-9]*)', v1.replace('-', '').lower()),\n                v2_models := re.findall(r'([a-zA-Z0-9]+(?:[a-zA-Z][0-9]|[0-9][a-zA-Z])[a-zA-Z0-9]*)', v2.replace('-', '').lower()),\n                any(m1 == m2 for m1 in v1_models for m2 in v2_models) if v1_models and v2_models else False\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: partial_match(v1, v2, title, specs, table)"
    ],
    "series_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: partial_match(v1, v2, title, specs, table)"
    ],
    "mpn_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: partial_match(v1, v2, title, specs, table)"
    ],
    "condition_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                val1_clean := v1.strip().lower() if v1 else \"\",\n                val2_clean := v2.strip().lower() if v2 else \"\",\n                any(\n                    val1_clean in [item.lower() for item in group] and\n                    val2_clean in [item.lower() for item in group]\n                    for group in condition_mappings.values()\n                )\n            ) and (\n                logger.debug(f\"Matched '{val1_clean}' with '{val2_clean}' via condition_mappings\", extra={'session_id': current_session_id}) or True\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                val1_clean := v1.strip().lower() if v1 else \"\",\n                val2_clean := v2.strip().lower() if v2 else \"\",\n                (val1_clean == \"bad\" and val2_clean == \"used\") or\n                (val2_clean == \"bad\" and val1_clean == \"used\")\n            ) and (\n                logger.debug(f\"Matched '{val1_clean}' with '{val2_clean}' as 'Bad' to 'Used' standalone\", extra={'session_id': current_session_id}) or True\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                val1_clean := v1.strip().lower() if v1 else \"\",\n                val2_clean := v2.strip().lower() if v2 else \"\",\n                val1_clean == \"used\" or val2_clean == \"used\"\n            ) and (\n                logger.debug(f\"Matched '{val1_clean}' with '{val2_clean}' as 'Used' is a wildcard\", extra={'session_id': current_session_id}) or True\n            )"
    ],
    "battery_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower().strip(),\n                v2_lower := v2.lower().strip(),\n                invalid_values := [\"fair\", \"bad\", \"defective\"],\n                equivalent_values := [\"yes\", \"included\", \"with battery\", \"w/ battery\", \"w/battery\", \"excellent\", \"good\", \"very good\"],\n                (v1_lower in invalid_values or v2_lower in invalid_values) and\n                (logger.debug(f\"Mismatch '{v1_lower}' with '{v2_lower}' for battery_key: One or both values indicate a defective battery status\", extra={'session_id': current_session_id}) or False)\n                or\n                (\n                    v1_lower in equivalent_values and\n                    v2_lower in equivalent_values and\n                    not (\n                        (v1_lower == \"excellent\" and v2_lower in [\"good\", \"very good\"]) or\n                        (v2_lower == \"excellent\" and v1_lower in [\"good\", \"very good\"])\n                    ) and\n                    (logger.debug(f\"Matched '{v1_lower}' with '{v2_lower}' for battery_key as equivalent battery statuses\", extra={'session_id': current_session_id}) or True)\n                )\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                \"defective\" not in (v2_lower := v2.lower().strip()) and\n                (v1_lower := v1.lower().strip()) and\n                (\n                    (v1_lower in [\"no battery\", \"no\", \"n/a\", \"not included\", \"missing\"] and\n                     v2_lower in [\"no battery\", \"no\", \"n/a\", \"not included\", \"missing\"]) or\n                    (v1_lower in [\"no battery\", \"no\", \"n/a\", \"not included\", \"missing\"] and\n                     v2_lower == \"no (battery cable is included inside)\") or\n                    (title is not None and\n                     ('battery_key' in title or 'battery_status_key' in title) and\n                     v1_lower in [\"no battery\", \"no\", \"n/a\", \"missing\"] and\n                     listing.get('table_data', []) and\n                     any(\n                         entry.get('table_battery_key', '').lower() in [\"no battery\", \"no\", \"n/a\", \"not included\", \"missing\"]\n                         for entry in listing.get('table_data', [])\n                     )) or\n                    (v1_lower in [\"with battery\", \"yes\"] and v2_lower.startswith(\"yes\")) or\n                    (v1_lower in [\"no battery\", \"no\", \"n/a\", \"not included\", \"missing\"] and\n                     \"one unit missing battery\" in v2_lower) or\n                    (\"one unit missing battery\" in v1_lower and\n                     v2_lower in [\"no battery\", \"no\", \"n/a\", \"not included\", \"missing\"]) or\n                    (v1_lower.startswith(\"no\") and v2_lower.startswith(\"no\"))\n                ) and\n                (logger.debug(f\"Matched '{v1_lower}' with '{v2_lower}' for battery_key\", extra={'session_id': current_session_id}) or True\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower().strip(),\n                v2_lower := v2.lower().strip(),\n                (\n                    (v1_lower in [\"no battery\", \"no\", \"n/a\", \"not included\", \"missing\"] and\n                     v2_lower in [\"no battery\", \"no\", \"n/a\", \"not included\", \"missing\"]) or\n                    (v1_lower.startswith(\"no\") and v2_lower.startswith(\"no\"))\n                ) and\n                (logger.debug(f\"Matched '{v1_lower}' with '{v2_lower}' for battery_key as equivalent non-battery statuses\", extra={'session_id': current_session_id}) or True\n            )  # Explicitly ensures 'No Battery' is equivalent to any value starting with 'No', e.g., 'No (cable is included)'"
    ],
    "network_type_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower().strip(),\n                v2_lower := v2.lower().strip(),\n                has_unlocked1 := \"unlocked\" in v1_lower,\n                has_unlocked2 := \"unlocked\" in v2_lower,\n                has_unlocked1 == has_unlocked2\n            ) and (\n                logger.debug(f\"Matched '{v1_lower}' with '{v2_lower}' based on 'Unlocked' presence equivalence\", extra={'session_id': current_session_id}) or True\n            )"
    ],
    "lock_status_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower().strip(),\n                v2_lower := v2.lower().strip(),\n                has_unlocked1 := \"unlocked\" in v1_lower or v1_lower == \"none\",\n                has_unlocked2 := \"unlocked\" in v2_lower or v2_lower == \"none\",\n                has_unlocked1 == has_unlocked2\n            ) and (\n                logger.debug(f\"Matched '{v1_lower}' with '{v2_lower}' based on 'Unlocked' or 'None' presence equivalence\", extra={'session_id': current_session_id}) or True\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower().strip(),\n                v2_lower := v2.lower().strip(),\n                (v1_lower == \"wifi only\" and v2_lower == \"locked\") or\n                (v2_lower == \"wifi only\" and v1_lower == \"locked\")\n            ) and (\n                logger.debug(f\"Matched '{v1_lower}' with '{v2_lower}' based on 'wifi only' to 'locked' equivalence\", extra={'session_id': current_session_id}) or True\n            )"
    ],
    "network_status_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower().strip(),\n                v2_lower := v2.lower().strip(),\n                (v1_lower == \"wifi only\" and v2_lower == \"locked\") or\n                (v2_lower == \"wifi only\" and v1_lower == \"locked\") or\n                (v1_lower == \"wifi only\" and v2_lower == \"network unlocked\") or\n                (v2_lower == \"wifi only\" and v1_lower == \"network unlocked\")\n            ) and (\n                logger.debug(f\"Matched '{v1_lower}' with '{v2_lower}' for network_status_key as 'wifi only' non-contradictory with lock/unlocked\", extra={'session_id': current_session_id}) or True\n            )"
    ],
    "network_carrier_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower().strip(),\n                v2_lower := v2.lower().strip(),\n                # Specific exact match: \"Unlocked\" == \"CDMA/GSM Fully Unlocked\"\n                (v1_lower == \"unlocked\" and v2_lower == \"cdma/gsm fully unlocked\") or\n                (v2_lower == \"unlocked\" and v1_lower == \"cdma/gsm fully unlocked\") or\n                # Original \"none\" to \"unlocked\" equivalence\n                (v1_lower == \"none\" and \"unlocked\" in v2_lower) or\n                (v2_lower == \"none\" and \"unlocked\" in v1_lower) or\n                # Exact match fallback\n                v1_lower == v2_lower\n            ) and (\n                logger.debug(f\"Matched '{v1_lower}' with '{v2_lower}' based on network carrier equivalence\", extra={'session_id': current_session_id}) or True\n            )"
    ],
    "carrier_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower().strip(),\n                v2_lower := v2.lower().strip(),\n                # Specific exact match: \"Unlocked\" == \"CDMA/GSM Fully Unlocked\"\n                (v1_lower == \"unlocked\" and v2_lower == \"cdma/gsm fully unlocked\") or\n                (v2_lower == \"unlocked\" and v1_lower == \"cdma/gsm fully unlocked\") or\n                # Original \"none\" to \"unlocked\" equivalence\n                (v1_lower == \"none\" and \"unlocked\" in v2_lower) or\n                (v2_lower == \"none\" and \"unlocked\" in v1_lower) or\n                # Exact match fallback\n                v1_lower == v2_lower\n            ) and (\n                logger.debug(f\"Matched '{v1_lower}' with '{v2_lower}' based on network carrier equivalence\", extra={'session_id': current_session_id}) or True\n            )"
    ],
    "brand_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: v1.lower().strip() in v2.lower().strip() or v2.lower().strip() in v1.lower().strip()",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                brand_equivalence := {'meraki': 'cisco', 'cisco': 'cisco', 'dell': 'dell', 'alienware': 'dell'},\n                v1_normalized := brand_equivalence.get(v1.lower().strip(), v1.lower().strip()),\n                v2_normalized := brand_equivalence.get(v2.lower().strip(), v2.lower().strip()),\n                v1_normalized == v2_normalized\n            ) and (\n                logger.debug(f\"Matched '{v1}' with '{v2}' as equivalent brands ('{v1_normalized}' == '{v2_normalized}')\", extra={'session_id': current_session_id}) or True\n            )"
    ],
    "operating_system_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: v1.lower() in [\"no os\", \"not included\", \"no\"] and v2.lower() in [\"no os\", \"not included\", \"no\"]  # Explicitly ensures 'no os' is equivalent to 'no'",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower().strip(),\n                v2_lower := v2.lower().strip(),\n                v1_lower.startswith(\"windows\") and\n                v2_lower.startswith(\"windows\") and\n                re.sub(r'\\s+pro$', '', v1_lower) == re.sub(r'\\s+pro$', '', v2_lower)\n            ) and (\n                logger.debug(f\"Matched '{v1_lower}' with '{v2_lower}' as Windows partial match\", extra={'session_id': current_session_id}) or True\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower().strip(),\n                v2_lower := v2.lower().strip(),\n                (v1_lower in [\"google\", \"google os\"] and v2_lower in [\"google\", \"google os\"])\n            ) and (\n                logger.debug(f\"Matched '{v1_lower}' with '{v2_lower}' as Google OS equivalence\", extra={'session_id': current_session_id}) or True\n            )"
    ],
    "device_type_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower().strip(),\n                v2_lower := v2.lower().strip(),\n                (v1_lower == \"dm\" and v2_lower == \"desktop\") or\n                (v2_lower == \"dm\" and v1_lower == \"desktop\")\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: expand_abbreviations(v1, v2) or partial_match(v1, v2, title, specs, table)"
    ],
    "type_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower().strip(),\n                v2_lower := v2.lower().strip(),\n                (v1_lower == \"workstation\" and v2_lower in [\"desktop\", \"laptop\"]) or\n                (v2_lower == \"workstation\" and v1_lower in [\"desktop\", \"laptop\"]) or\n                (v1_lower == \"dm\" and v2_lower == \"desktop\") or\n                (v2_lower == \"dm\" and v1_lower == \"desktop\")\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: expand_abbreviations(v1, v2) or partial_match(v1, v2, title, specs, table)"
    ],
    "form_factor_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                title_lower := title.get('form_factor_key', '').lower().strip() if title else '',\n                specs_lower := specs.get('form_factor_key', '').lower().strip() if specs else '',\n                \"tower\" in title_lower and (\"sff\" in specs_lower or \"small form factor (sff)\" in specs_lower)\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                any(re.search(r'\\b' + re.escape(term) + r'\\b', v1.lower())\n                    for term in [\"dm\", \"desktop mini\", \"mini desktop\", \"mini tower\", \"mt\", \"micro pc\"]) and\n                any(re.search(r'\\b' + re.escape(term) + r'\\b', v2.lower())\n                    for term in [\"dm\", \"desktop mini\", \"mini desktop\", \"mini tower\", \"mt\", \"micro pc\"])\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: expand_abbreviations(v1, v2) or partial_match(v1, v2, title, specs, table)"
    ],
    "gpu_description_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: gpu_equivalence(v1, v2)",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: ((v1.lower().strip() == 'amd radeon graphics' and v2.lower().strip() in ['integrated', 'integrated graphics', 'on-board']) or (v2.lower().strip() == 'amd radeon graphics' and v1.lower().strip() in ['integrated', 'integrated graphics', 'on-board']))"
    ],
    "gpu_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: gpu_equivalence(v1, v2)",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: ((v1.lower().strip() == 'amd radeon graphics' and v2.lower().strip() in ['integrated', 'integrated graphics', 'on-board']) or (v2.lower().strip() == 'amd radeon graphics' and v1.lower().strip() in ['integrated', 'integrated graphics', 'on-board']))"
    ],
    "videocard_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: gpu_equivalence(v1, v2)",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: ((v1.lower().strip() == 'amd radeon graphics' and v2.lower().strip() in ['integrated', 'integrated graphics', 'on-board']) or (v2.lower().strip() == 'amd radeon graphics' and v1.lower().strip() in ['integrated', 'integrated graphics', 'on-board']))"
    ],
    "matched_text_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower(),\n                v2_lower := v2.lower(),\n                (\"graphics\" in v1_lower or \"gpu\" in v1_lower or \"video\" in v1_lower or \"intel\" in v1_lower) and\n                (\"graphics\" in v2_lower or \"gpu\" in v2_lower or \"video\" in v2_lower or \"intel\" in v2_lower)\n            ) and gpu_equivalence(v1, v2)",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower().strip(),\n                v2_lower := v2.lower().strip(),\n                (v1_lower == \"matched_text n/a\" and v2_lower == \"none (has\") or\n                (v2_lower == \"matched_text n/a\" and v1_lower == \"none (has\")\n            ) and (\n                logger.debug(f\"Matched '{v1_lower}' with '{v2_lower}' as 'matched_text n/a' vs 'none (has'\", extra={'session_id': current_session_id}) or True\n            )",
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: v1 == v2"
    ],
    "connectivity_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                v1_lower := v1.lower(),\n                v2_lower := v2.lower(),\n                v1_items := [item.strip() for item in v1_lower.split(',')] if ',' in v1_lower else [v1_lower],\n                v2_items := [item.strip() for item in v2_lower.split(',')] if ',' in v2_lower else [v2_lower],\n                any(v1_item in v2_items or v2_lower in v1_item for v1_item in v1_items) or\n                any(v2_item in v1_items or v1_lower in v2_item for v2_item in v2_items)\n            ) and (\n                logger.debug(f\"Matched '{v1_lower}' with '{v2_lower}' as connectivity subset\", extra={'session_id': current_session_id}) or True\n            )"
    ],
    "ram_range_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                range_match := re.match(r'^(\\d+)(gb|mb|tb)-(\\d+)(gb|mb|tb)$', v1.lower().strip()),\n                value_match := re.match(r'^(\\d+)(gb|mb|tb)$', v2.lower().strip()),\n                unit_multipliers := {'mb': 0.001, 'gb': 1, 'tb': 1000},\n                range_match and value_match and (\n                    min_size_gb := int(range_match.group(1)) * unit_multipliers[range_match.group(2)],\n                    max_size_gb := int(range_match.group(3)) * unit_multipliers[range_match.group(4)],\n                    value_size_gb := int(value_match.group(1)) * unit_multipliers[value_match.group(2)],\n                    min_size_gb <= value_size_gb <= max_size_gb\n                )\n            ) and (\n                logger.debug(f\"RAM range match: '{v2}' is within range '{v1}'\", extra={'session_id': current_session_id}) or True\n            )"
    ],
    "storage_range_key": [
        "lambda v1, v2, title=None, specs=None, table=None, is_mobile_device=False: (\n                range_match := re.match(r'^(\\d+)(gb|mb|tb)-(\\d+)(gb|mb|tb)$', v1.lower().strip()),\n                value_match := re.match(r'^(\\d+)(gb|mb|tb)$', v2.lower().strip()),\n                unit_multipliers := {'mb': 0.001, 'gb': 1, 'tb': 1000},\n                range_match and value_match and (\n                    min_size_gb := int(range_match.group(1)) * unit_multipliers[range_match.group(2)],\n                    max_size_gb := int(range_match.group(3)) * unit_multipliers[range_match.group(4)],\n                    value_size_gb := int(value_match.group(1)) * unit_multipliers[value_match.group(2)],\n                    min_size_gb <= value_size_gb <= max_size_gb\n                )\n            ) and (\n                logger.debug(f\"Storage range match: '{v2}' is within range '{v1}'\", extra={'session_id': current_session_id}) or True\n            )"
    ]
}